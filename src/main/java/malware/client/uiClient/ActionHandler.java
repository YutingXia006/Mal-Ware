package malware.client.uiClient;

import javafx.embed.swing.SwingFXUtils;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Label;
import javafx.scene.image.WritableImage;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import malware.client.ClientNetInterface;
import malware.client.InstructionFactory;
import malware.client.malFunctions.BigSquareFunction;
import malware.client.malFunctions.FunctionHandler;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.imageio.ImageIO;
import java.awt.image.RenderedImage;
import java.io.File;
import java.io.IOException;
import java.net.ConnectException;
import java.util.*;

public class ActionHandler {
    private static final Logger log = LogManager.getLogger(ActionHandler.class);
    private InstructionFactory instructionFactory = new InstructionFactory();
    private ClientNetInterface clientNetInterface;
    private FunctionHandler functionHandler;
    private String currentFunction;
    private Stage primaryStage;
    private ArrayList<Thread> threads;
    private GraphicsContext gc;
    private String drawingString;
    private int historyIndex = 0;

    //drawing from paintLog from server
    private void redraw() {
        log.info("Redrawing");
        Canvas c = gc.getCanvas();
        gc.clearRect(0, 0, c.getWidth(), c.getHeight());
        for (int i = 0; i <= clientNetInterface.paintLog.size() - 1; i++) {
            drawFromPaintLog(i, true);
        }
    }

    //undoing last action,saving the action for redo and deleting from paintLog
    protected void undo() {
        log.info(this.clientNetInterface.paintLog);
        if (this.historyIndex >= 0) {
            log.info("Undoing");
            this.clientNetInterface.deleteLastActionFromPaintLog();
            this.redraw();
        } else {
            log.info("Nothing to undo yet.");
        }

    }

    //redoing last action
    protected void redo() {
        if (historyIndex < clientNetInterface.paintLog.size() - 1) {
            clientNetInterface.addLastActionToPaintLog();
            redraw();
            log.info("Redoing");
        } else {
            log.info("No action to redo");
        }
    }

    public ActionHandler(Stage primaryStage, ClientNetInterface clientNetInterface, ArrayList<Thread> threads, GraphicsContext gc, FunctionHandler functionHandler) {
        this.primaryStage = primaryStage;
        this.clientNetInterface = clientNetInterface;
        this.threads = threads;
        this.gc = gc;
        this.functionHandler = functionHandler;
    }

    protected boolean submitClientInfo(String hostname, int port, String name, Label errorLabel) {
        // Instantiate the client class and start its thread
        boolean success;
        try {
            clientNetInterface.startInterface(hostname, port, name);
            Thread clientThread = new Thread(clientNetInterface);
            clientThread.setDaemon(true);
            clientThread.start();
            threads.add(clientThread);

            success = true;
        } catch (ConnectException e) {
            errorLabel.setTextFill(Color.RED);
            success = false;
            errorLabel.setText("Invalid host name, try again");
            log.error("Invalid host name");
        } catch (NumberFormatException | IOException e) {
            errorLabel.setTextFill(Color.RED);
            success = false;
            errorLabel.setText("Invalid port number, try again");
            log.error("Invalid port number");
        }
        return success;


    }

    protected void mousePressed(MouseEvent event) {
        if (event.getButton() == MouseButton.PRIMARY) {
            historyIndex++;
            String selectedFunction = functionHandler.getSelectedFunction();
            if(selectedFunction.equals(functionHandler.getFunctionButtons().get(0).getText())){
                drawingString = instructionFactory.createInstruction(
                        historyIndex,
                        clientNetInterface.getName(),
                        "press",
                        event,
                        gc);
                gc.beginPath();
                gc.moveTo(event.getX(), event.getY());
                gc.stroke();
            }else{
                drawingString = instructionFactory.createInstruction(
                        historyIndex,
                        clientNetInterface.getName(),
                        selectedFunction,
                        event,
                        gc);
                functionHandler.takeOver(selectedFunction, (float) event.getX(), (float) event.getY());
            }

            clientNetInterface.writeToServer(drawingString);
        }
    }

    protected void mouseDragged(MouseEvent event) {
        if (event.getButton() == MouseButton.PRIMARY) {
            String selectedFunction = functionHandler.getSelectedFunction();
            if(selectedFunction.equals(functionHandler.getFunctionButtons().get(0).getText())){
                drawingString = instructionFactory.createInstruction(
                        historyIndex,
                        clientNetInterface.getName(),
                        "drag",
                        event,
                        gc);
                gc.lineTo(event.getX(), event.getY());
                gc.stroke();
                clientNetInterface.writeToServer(drawingString);
            }


        }
    }

    protected void mouseReleased(MouseEvent event) {
        if (event.getButton() == MouseButton.PRIMARY) {
            String selectedFunction = functionHandler.getSelectedFunction();
            if(selectedFunction.equals(functionHandler.getFunctionButtons().get(0).getText())){
                drawingString = instructionFactory.createInstruction(
                        historyIndex,
                        clientNetInterface.getName(),
                        "release",
                        event,
                        gc);
                gc.stroke();
                gc.closePath();
                clientNetInterface.writeToServer(drawingString);
            }

        }
    }

    protected void saveButton(Canvas canvas) {
        {
            FileChooser savefile = new FileChooser();
            savefile.setTitle("Save File");
            savefile.setInitialFileName("meisterwerk");
            FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter("PNG files (*.png)", "*.png");
            savefile.getExtensionFilters().add(extFilter);

            File file = savefile.showSaveDialog(primaryStage);
            log.info("Is file null? " + file);
            if (file != null) {
                try {
                    WritableImage writableImage = new WritableImage((int) canvas.getWidth(), (int) canvas.getHeight());
                    canvas.snapshot(null, writableImage);
                    RenderedImage renderedImage = SwingFXUtils.fromFXImage(writableImage, null);
                    ImageIO.write(renderedImage, "png", file);
                } catch (IOException ex) {
                    ex.printStackTrace();
                    log.info("Error!");
                }
            }
        }
    }

    protected void onServerMessage() {
        drawFromPaintLog(clientNetInterface.paintLog.size() - 1, false);

    }

    protected void drawFromPaintLog(int instructionIndex, boolean ignoreRedraw) {
        log.info("Drawing from PaintLog.");
        if (clientNetInterface.paintLog.size() > 0) {
            String message = clientNetInterface.paintLog.get(instructionIndex);
            String[] completeInstruction = message.split(":");
            if (!(clientNetInterface.getName().equals(completeInstruction[1])) || ignoreRedraw) {
                String strokeColor = completeInstruction[3];
                String lineWidth = completeInstruction[4];
                gc.setStroke(Paint.valueOf(strokeColor));
                gc.setLineWidth(Double.parseDouble(lineWidth));
                String[] coords = completeInstruction[5].split(",");
                String instructionName = completeInstruction[2];
                switch (instructionName) {
                    case "press" -> {
                        gc.beginPath();
                        gc.moveTo(Float.parseFloat(coords[0]), Float.parseFloat(coords[1]));
                        gc.stroke();
                    }
                    case "drag" -> {
                        gc.lineTo(Float.parseFloat(coords[0]), Float.parseFloat(coords[1]));
                        gc.stroke();
                    }
                    case "release" -> {
                        gc.lineTo(Float.parseFloat(coords[0]), Float.parseFloat(coords[1]));
                        gc.stroke();
                        gc.closePath();
                    }
                    default -> {
                        functionHandler.takeOver(instructionName, Float.parseFloat(coords[0]), Float.parseFloat(coords[1]));
                    }
                }
            }
        }
    }
}
