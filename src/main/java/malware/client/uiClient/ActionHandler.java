package malware.client.uiClient;

import javafx.embed.swing.SwingFXUtils;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Label;
import javafx.scene.image.WritableImage;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import malware.client.CanvasPainter;
import malware.client.ClientNetInterface;
import malware.client.InstructionFactory;
import malware.client.UserAction;
import malware.client.malFunctions.FunctionHandler;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.imageio.ImageIO;
import java.awt.image.RenderedImage;
import java.io.File;
import java.io.IOException;
import java.net.ConnectException;
import java.util.*;

public class ActionHandler {
    private static final Logger log = LogManager.getLogger(ActionHandler.class);
    private FunctionHandler functionHandler;
    private ClientNetInterface clientNetInterface;

    private CanvasPainter painter;
    private Stage primaryStage;
    private ArrayList<Thread> threads;
    private GraphicsContext gc;
    private int historyIndex = 0;




    //drawing from paintLog from server
    private void redraw() {
        log.warn("Redrawing");
        Canvas c = gc.getCanvas();
        gc.clearRect(0, 0, c.getWidth(), c.getHeight());
        for (int i = 0; i <= clientNetInterface.getPaintLog().size() - 1; i++) {
            drawFromPaintLog(i, true);
        }
    }

    //undoing last action,saving the action for redo and deleting from paintLog
    protected void undo() {
        log.warn(this.clientNetInterface.getPaintLog());
        if (this.historyIndex >= 0) {
            log.warn("Undoing");
            this.clientNetInterface.deleteLastActionFromPaintLog();
            this.redraw();
        } else {
            log.warn("Nothing to undo yet.");
        }

    }

    //redoing last action
    protected void redo() {
        if (historyIndex < clientNetInterface.getPaintLog().size() - 1) {
            clientNetInterface.addLastActionToPaintLog();
            redraw();
            log.warn("Redoing");
        } else {
            log.warn("No action to redo");
        }
    }

    public ActionHandler(Stage primaryStage, ClientNetInterface clientNetInterface, CanvasPainter painter, ArrayList<Thread> threads, GraphicsContext gc, FunctionHandler functionHandler) {
        this.primaryStage = primaryStage;
        this.clientNetInterface = clientNetInterface;
        this.threads = threads;
        this.gc = gc;
        this.painter = painter;
        this.functionHandler = functionHandler;
    }

    protected boolean submitClientInfo(String hostname, int port, String name, Label errorLabel) {
        // Instantiate the client class and start its thread
        boolean success;
        try {
            clientNetInterface.startInterface(hostname, port, name);
            Thread clientThread = new Thread(clientNetInterface);
            clientThread.setDaemon(true);
            clientThread.start();
            threads.add(clientThread);

            success = true;
        } catch (ConnectException e) {
            errorLabel.setTextFill(Color.RED);
            success = false;
            errorLabel.setText("Invalid host name, try again");
            log.error("Invalid host name");
        } catch (NumberFormatException | IOException e) {
            errorLabel.setTextFill(Color.RED);
            success = false;
            errorLabel.setText("Invalid port number, try again");
            log.error("Invalid port number");
        }
        return success;


    }

    protected void mouseAction(UserAction action, double x, double y) {

        if (action == UserAction.PRESS) {
            historyIndex++;
            clientNetInterface.bufferServerInput();
        }



        String selectedFunction = functionHandler.getSelectedFunction();

        String drawingButtonName = functionHandler.getFunctionButtons().get(0).getText();



        boolean drawingButtonPressed = selectedFunction.equals(drawingButtonName);

        if(drawingButtonPressed){
            painter.draw(historyIndex,action,x,y,true);
        }else{

            functionHandler.takeOver(historyIndex,action, selectedFunction, x, y);

        }
        if(action == UserAction.RELEASE){
            clientNetInterface.dismissServerBuffer();
        }



    }


    protected void saveButton(Canvas canvas) {
        {
            FileChooser savefile = new FileChooser();
            savefile.setTitle("Save File");
            savefile.setInitialFileName("meisterwerk");
            FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter("PNG files (*.png)", "*.png");
            savefile.getExtensionFilters().add(extFilter);

            File file = savefile.showSaveDialog(primaryStage);
            log.warn("Is file null? " + file);
            if (file != null) {
                try {
                    WritableImage writableImage = new WritableImage((int) canvas.getWidth(), (int) canvas.getHeight());
                    canvas.snapshot(null, writableImage);
                    RenderedImage renderedImage = SwingFXUtils.fromFXImage(writableImage, null);
                    ImageIO.write(renderedImage, "png", file);
                } catch (IOException ex) {
                    ex.printStackTrace();
                    log.warn("Error!");
                }
            }
        }
    }

    protected void onServerMessage() {
        drawFromPaintLog(clientNetInterface.getPaintLog().size() - 1, false);

    }

    protected void drawFromPaintLog(int instructionIndex, boolean ignoreRedraw) {
        log.warn("Drawing from PaintLog.");
        if (clientNetInterface.getPaintLog().size() > 0) {
            String message = clientNetInterface.getPaintLog().get(instructionIndex);
            String[] completeInstruction = message.split(":");
            // 0 historyIndex : 1 clientName : 2 action : 3 color : 4 lineWidth : 5 x,y
            if ((!clientNetInterface.getName().equals(completeInstruction[1])) || ignoreRedraw) {
                int historyIndex = Integer.parseInt(completeInstruction[0]);
                String instructionName = completeInstruction[2];
                String strokeColor = completeInstruction[3];
                String lineWidth = completeInstruction[4];
                gc.setStroke(Paint.valueOf(strokeColor));
                gc.setLineWidth(Double.parseDouble(lineWidth));
                String[] coords = completeInstruction[5].split(",");
                float x = Float.parseFloat(coords[0]);
                float y = Float.parseFloat(coords[1]);
                UserAction instructedAction;

                if(instructionName.equals(UserAction.PRESS.toString())){
                    instructedAction = UserAction.PRESS;
                } else if (instructionName.equals(UserAction.DRAG.toString())) {
                    instructedAction = UserAction.DRAG;
                } else {
                    instructedAction = UserAction.RELEASE;
                }

                drawWithPainter(historyIndex,instructedAction, x, y, false);


            }
        }
    }

    private void drawWithPainter(int historyIndex, UserAction action, double x, double y, boolean sendToServer){
        painter.draw(historyIndex,action, x, y, false);
    }
}
